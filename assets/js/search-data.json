{
  
    
        "post0": {
            "title": "데이터 시각화 7",
            "content": "import numpy as np import matplotlib.pyplot as plt . lambda . 예제1 : 람다 표현식 자체가 하나의 오브젝트 | . (lambda x : x + 1)(300) #이름도 안 붙이고 사용하고 싶을 때 사용 # lambda 가 실행되는 순간 메모리상에 함수 오브젝트가 저장됨 . 301 . (lambda x : (x-2)**2)(2) . 0 . &quot;lambda x: (x-2)**2&quot; 는 lambda(x)=(x-2)^2lambda(x)=(x−2)^2의 느낌으로 기억하면 쉬움 | . (lambda x: (x-2)**2)(4) # 입력5 -&gt; 출력 (4-2)^2 =4 . 4 . (lambda x: (x-2)**2)(6) # 입력6 -&gt; 출력 (6-2)^2 =16 . 16 . (lambda x: (x-2)**2)(-2) # 입력-2 -&gt; 출력 (-2-2)^2 =16 . 16 . 예제2: 람다표현식에 이름을 줄 수 있음. | . f = lambda x: (x-2)**2 . f(2),f(4),f(6),f(-2) . (0, 4, 16, 16) . 위의 코드는 아래와 같다. . def f(x): return (x-2)**2 f(2),f(4),f(6),f(-2) . (0, 4, 16, 16) . 예제3: 조건부 출력 | . f = lambda x,y: x if x&gt;y else y # x,y가 입력 -&gt; x&gt;y 일때만 x를 리턴하고 그렇지않으면 y를 리턴 = 큰값을 리턴하라는 소리임 . f(1,20) . 20 . 예제4: 람다표현식들의 리스트 | . fl = [lambda x: x, lambda x: x**2, lambda x: x**3] #한 번에 묶어서 리스트로 만들 수 있음 . fl[0](100) #렝이 있으면 원소에 접근 가능[], 그리고 거기에다가 숫자입력해서 쓸 수 있음 . 100 . for f in fl: print(f(2)) . 2 4 8 . for s in [&#39;a&#39;, lambda x : x, &#39;c&#39;]: print(s) . a &lt;function &lt;lambda&gt; at 0x7f9142898b80&gt; c . x = np.linspace(-1,1,100) for f in fl: plt.plot(x,f(x),&#39;--&#39;) . 예제5: 람다표현식들의 딕셔너리 | . fd = {&#39;f1&#39;:lambda x: x, &#39;f2&#39;:lambda x: x**2, &#39;f3&#39;:lambda x: x**3} fd . {&#39;f1&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;, &#39;f2&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;, &#39;f3&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;} . fd[k] . &lt;function __main__.&lt;lambda&gt;(x)&gt; . for k in fd: plt.plot(x,fd[k](x),&#39;--&#39;) #fd[k] : 함수 오브젝트 . 예제6: 람다표현식을 리턴하는 함수 (함수를 리턴하는 함수) | . (예비학습) 함수 g(x)g(x)가 정의되어 있을때 $ frac{d}{dx}g(x)$의 값을 계산해보자(도함수) . g = lambda x : x**2 . g(3) . 9 . gg = lambda x : (g(x+0.001)-g(x))/0.001 . gg(4) . 8.0010000000037 . (목표) 도함수를 구해주는 derivate 함수를 정의하자. 이 함수는 임의의 함수 g를 입력으로 받으면, g의 도함수(gg)가 리턴되는 기능을 가진다. . def derivate(g): return lambda x: (g(x+0.001)-g(x))/0.001 . (사용1) . g = lambda x: np.sin(x) . gg =derivate(g) . x = np.linspace(0,6.28, 1000) . plt.plot(x,g(x)) plt.plot(x,gg(x)) . [&lt;matplotlib.lines.Line2D at 0x7f916195cd90&gt;] . (사용2) . g0 = lambda x: (1/6)*x**3 g1 = derivate(g0) # (1/2)x^2 g2 = derivate(g1) # x . x = np.linspace(-1,1,100) plt.plot(x,g0(x),&#39;--&#39;,label=r&#39;$g_0(x)= frac{1}{6}x^3$&#39;) plt.plot(x,g1(x),&#39;--&#39;,label=r&#39;$g_1(x)= frac{1}{2}x^2$&#39;) plt.plot(x,g2(x),&#39;--&#39;,label=r&#39;$g_2(x)=x$&#39;) plt.legend(fontsize=15); . 예제7 | . derivate = lambda g: lambda x: (g(x+0.001)-g(x))/0.001 . &#47605; . x=[1,2,3] f = lambda x: x+1 y = list(map(f,x)) . (다른구현1) . list(map(lambda x: x+1,[1,2,3])) . [2, 3, 4] . (다른구현2) . f = lambda x: x+1 [f(xi) for xi in [1,2,3]] . [2, 3, 4] . (다른구현3) . [(lambda x: x+1)(xi) for xi in [1,2,3]] . [2, 3, 4] . 예제2: 문자열을 입력으로 받고 대문자이면 True, 소문자이면 False | . x= list(&#39;ABCabc&#39;) # x = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] f = lambda s: s.isupper() y = list(map(f,x)) . 예제3 - 두개의 입력을 받는 함수는 맵을 이용하는 것이 리스트 컴프리헨션보가 조금 편한 것 같다. | . list(map(lambda x,y: x+y, [1,2,3],[-1,-2,-3])) . [0, 0, 0] . (다른구현)-- 리스트컴프리헨션 . f = lambda x,y: x+y [f(x,y) for x,y in zip([1,2,3],[-1,-2,-3])] . [0, 0, 0] . 예제4 : 맵은 &quot;하나의 함수에 다양한 입력&quot;을 적용하는 경우에만 사용가능, 리스트 컴프리헨션은 &quot;다양한 함수에 다양한 입력&quot; 지원 | . flst = [lambda x: x+1, lambda x: x+2, lambda x:x+3] . 맵으로 구현 시도 . list(map(flst,[-1,-2,-3])) -&gt; 실패 . Input In [18] list(map(flst,[-1,-2,-3])) -&gt; 실패 ^ SyntaxError: invalid syntax . 리스트컴프리헨션으로 구현시도 -&gt; 성공 . [f(x) for f,x in zip(flst,[-1,-2,-3])] . [0, 0, 0] . 종합: map과 리스트컴프리헨션과 비교 | . map은 for문을 위한 i등의 인덱스를 쓰지 않지만 리스트컴프리헨션은 필요함 . map은 좀더 리스트컴프리헨션보다 제약적으로 사용할 수 밖에 없음. . &#51064;&#45937;&#49905; 1&#45800;&#44228;-- &#51064;&#45937;&#49905;&#51032; 4&#44032;&#51648; &#52968;&#49481; . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; . import pandas as pd . df=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/dv2022.csv&#39;) df . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . ... ... | ... | ... | ... | . 195 55 | 70 | 40 | 95 | . 196 65 | 85 | 25 | 85 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 199 50 | 95 | 45 | 85 | . 200 rows × 4 columns . 앞으로는 위와 같은 df형태를 가정할 것이다. 즉 column의 이름은 문자열, row의 이름은 0부터 시작하는 정수로 가정한다. . | 아래와 같은 형태는 일단 생각하지 않는다. . | . pd.DataFrame({&#39;att&#39;:[60,65,80,90],&#39;rep&#39;:[50,100,90,100]},index=[&#39;규빈&#39;,&#39;영미&#39;,&#39;성준&#39;,&#39;혜미&#39;]) . att rep . 규빈 60 | 50 | . 영미 65 | 100 | . 성준 80 | 90 | . 혜미 90 | 100 | . df&#51032; 4&#44032;&#51648; &#52968;&#49481; . 원소에 접근하는 4가지 방법: ., [], .iloc[], .loc[] | . &#52968;&#49481;1: &#53364;&#47000;&#49828;&#45712;&#45196; . 컨셉1: df는 인스턴스이다. 그리고 df.att, df.rep,df.mid, df.fin 와 같이 col이름에 대응하는 속성이 있다 | . df.head() . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . df.rep #언제유용? 열의 이름을 대충 알고 있을 경우 자동완성으로 쉽게 선택가능 . 0 45 1 30 2 85 3 35 4 60 .. 195 70 196 85 197 85 198 65 199 95 Name: rep, Length: 200, dtype: int64 . &#52968;&#49481;2: &#46357;&#49492;&#45320;&#47532; +&#945; &#45712;&#45196; . 컨셉2: df는 컬럼이름이 key, 컬럼의데이터가 value가 되는 dictionary로 이해할 수 있다. 즉 아래의 dct와 같은 딕셔너리로 이해할 수 있다. | . dct = dict(df) . dct.keys(), df.keys() . (dict_keys([&#39;att&#39;, &#39;rep&#39;, &#39;mid&#39;, &#39;fin&#39;]), Index([&#39;att&#39;, &#39;rep&#39;, &#39;mid&#39;, &#39;fin&#39;], dtype=&#39;object&#39;)) . col indexing | 예시1: dct가 가능하면 df도 가능하다. | . df[&#39;att&#39;] #dct[&#39;att&#39;] . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . 예시2: dct가 가능하면 df도 가능하다. (2) | . df.get(&#39;att&#39;) . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . 예시3: dct에서 불가능하지만 df에서 가능한것도 있다. | . df.get([&#39;att&#39;, &#39;rep&#39;]) . att rep . 0 65 | 45 | . 1 95 | 30 | . 2 65 | 85 | . 3 55 | 35 | . 4 80 | 60 | . ... ... | ... | . 195 55 | 70 | . 196 65 | 85 | . 197 85 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 200 rows × 2 columns . df.get([&#39;att&#39;,&#39;rep&#39;]) . att rep . 0 65 | 45 | . 1 95 | 30 | . 2 65 | 85 | . 3 55 | 35 | . 4 80 | 60 | . ... ... | ... | . 195 55 | 70 | . 196 65 | 85 | . 197 85 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 200 rows × 2 columns . 예시4: dct에서 불가능하지만 df에서 가능한것도 있다. (2) | . dct[[&#39;att&#39;,&#39;rep&#39;]] . TypeError Traceback (most recent call last) Input In [47], in &lt;cell line: 1&gt;() -&gt; 1 dct[[&#39;att&#39;,&#39;rep&#39;]] TypeError: unhashable type: &#39;list&#39; . df[[&#39;att&#39;,&#39;rep&#39;]] . att rep . 0 65 | 45 | . 1 95 | 30 | . 2 65 | 85 | . 3 55 | 35 | . 4 80 | 60 | . ... ... | ... | . 195 55 | 70 | . 196 65 | 85 | . 197 85 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 200 rows × 2 columns . row indexing | 예시5: dct에서 불가능하지만 df에서 가능한것도 있다. (3) | . dct[:5] . TypeError Traceback (most recent call last) Input In [50], in &lt;cell line: 1&gt;() -&gt; 1 dct[:5] TypeError: unhashable type: &#39;slice&#39; . df[:5] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . &#52968;&#49481;3: &#45336;&#54028;&#51060;&#45712;&#45196; . 컨셉3: df.iloc은 넘파이에러이처럼 생각가능하다. | . 즉 아래의 arr와 같은 넘파이어레이로 생각가능하다. . import numpy as np . arr = np.array(df) #arr . row indexing | 예시1: 단일레이블 | . arr[0,] #arr[0] . array([65, 45, 0, 10]) . df.iloc[0,] #df.iloc[0] . att 65 rep 45 mid 0 fin 10 Name: 0, dtype: int64 . 예시2: 레이블의 리스트 | . arr[[0,1,2],:] # 처음 3개의 row 선택 arr[[0,1,2],] arr[[0,1,2]] . array([[65, 45, 0, 10], [95, 30, 60, 10], [65, 85, 15, 20]]) . df.iloc[[0,1,2],:] # 처음 3개의 row 선택 df.iloc[[0,1,2],] df.iloc[[0,1,2]] #데이터 프레임.iloc[] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 예시3: 슬랑이싱 | . arr[0:3,:] # 처음 3개의 row선택, 끝점포함X arr[0:3,] arr[0:3] . array([[65, 45, 0, 10], [95, 30, 60, 10], [65, 85, 15, 20]]) . df.iloc[0:3,:] # 처음 3개의 row선택, 끝점포함X df.iloc[0:3,] df.iloc[0:3] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . col indexing | 예시1: 단일레이블 | . df.iloc[:,0] # first column # arr[:,0] # first column . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . 예시2: 레이블의 리스트 | . df.iloc[:,[0,2]] # col1, col3 을 선택 # arr[:,[0,2]] # col1, col3 을 선택 . att mid . 0 65 | 0 | . 1 95 | 60 | . 2 65 | 15 | . 3 55 | 35 | . 4 80 | 55 | . ... ... | ... | . 195 55 | 40 | . 196 65 | 25 | . 197 85 | 100 | . 198 80 | 35 | . 199 50 | 45 | . 200 rows × 2 columns . 예시3: 슬랑이싱 | . df.iloc[:,0:3] # 처음 3개의 col선택, 끝점포함X #arr[:,0:3] . att rep mid . 0 65 | 45 | 0 | . 1 95 | 30 | 60 | . 2 65 | 85 | 15 | . 3 55 | 35 | 35 | . 4 80 | 60 | 55 | . ... ... | ... | ... | . 195 55 | 70 | 40 | . 196 65 | 85 | 25 | . 197 85 | 85 | 100 | . 198 80 | 65 | 35 | . 199 50 | 95 | 45 | . 200 rows × 3 columns . df.iloc[::2,0:3] . att rep mid . 0 65 | 45 | 0 | . 2 65 | 85 | 15 | . 4 80 | 60 | 55 | . 6 65 | 70 | 60 | . 8 95 | 55 | 65 | . ... ... | ... | ... | . 190 95 | 35 | 40 | . 192 100 | 40 | 80 | . 194 65 | 40 | 65 | . 196 65 | 85 | 25 | . 198 80 | 65 | 35 | . 100 rows × 3 columns . &#52968;&#49481; 4: &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#45712;&#45196; . 컨셉4: df.loc은 새로운 느낌.. (R에 익숙하면 df.loc이 dataframe 혹은 티블느낌이라고 보시면 됩니다) - 코랩에서만 사용 가능 | . col 이름을 알아야하는 부담감 | . . : 앞글자만 대충 알아도 자동완성 가능 . []: 정확한 col 이름을 알아야 함 . .loc: 보통 정확한 col 이름을 알아야 하지만 슬라이싱 이용시 양 끝의 컬럼이름만 알면 무방 . .iloc: 정확한 col 이름을 몰라도 번호로 인덱싱 가능 . 자주하는 실수 | . df[&#39;att&#39;] # 가능 # df.loc[&#39;att&#39;] # 불가능 df.loc[:,&#39;att&#39;] # 가능 . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . df: &#51064;&#45937;&#49905; 2&#45800;&#44228;-- &#54596;&#53552;&#47553;(&#53945;&#51221;&#51312;&#44148;&#50640; &#47582;&#45716; row&#47484; &#49440;&#53469;) . att &gt; 90 and rep &lt; 50 . 방법1: .query()를 이용 | .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/17/lambda.html",
            "relUrl": "/python/2022/10/17/lambda.html",
            "date": " • Oct 17, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "더하기",
            "content": "1+1 . 2 . 2+3 . 5 .",
            "url": "https://g-gg-ggg.github.io/Oppps/2022/10/17/test.html",
            "relUrl": "/2022/10/17/test.html",
            "date": " • Oct 17, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "10월 14일 숙제",
            "content": "다음과 같은 데이터프레임을 불러온 뒤 물음에 답하라 .",
            "url": "https://g-gg-ggg.github.io/Oppps/2022/10/14/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%88%99%EC%A0%9C.html",
            "relUrl": "/2022/10/14/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%88%99%EC%A0%9C.html",
            "date": " • Oct 14, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "10월 12일 숙제",
            "content": "아래와 같이 0~9까지 포함된 리스트를 만들어라 . x=list(range(10)) x . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 아래와 동일한 기능을 수행하는 함수를 lambda expression으로 정의하라. . def f(xi): return &#39;짝&#39; if (xi % 2)==0 else &#39;홀&#39; . f = lambda x : &quot;짝&quot; if (x%2) == 0 else &quot;홀&quot; . map과 lambda expression 을 이용하여 아래와 같은 결과를 만들어라. (리스트컴프리헨션, for문 사용금지) . y = list(map(f,x)) y . [&#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;] .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/12/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%88%99%EC%A0%9C.html",
            "relUrl": "/python/2022/10/12/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%88%99%EC%A0%9C.html",
            "date": " • Oct 12, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "데이터 시각화 6",
            "content": "import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns . x1,y1 = np.random.multivariate_normal([0,0],[[1,0],[0,1]],size=1000).T x2,y2 = np.random.multivariate_normal([2,2],[[1,0.7],[0.7,1]],size=1000).T #이변량정규분포에서 샘플추출 (추출코드를 기억할 필요는 없음) #특징: x1,y1은 무상관으로 x2,y2는 선형관계를 가지도록 추출 . plt.plot(x1,y1,&#39;o&#39;) plt.plot(x2,y2,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fdb59fdc1f0&gt;] . sns.scatterplot(data=None,x=x1,y=y1) #데이터 프레임이 없는 형태 sns.scatterplot(data=None,x=x2,y=y2) . wide df . df1 = data=pd.DataFrame({&#39;x&#39;:x1,&#39;y&#39;:y1}) #딕셔너리를 데이터 프레임에 넣어줌 df1 . x y . 0 -0.649907 | 0.595720 | . 1 1.820380 | 0.198625 | . 2 0.100658 | 0.239103 | . 3 -1.545113 | -0.951085 | . 4 0.064387 | -1.128326 | . ... ... | ... | . 995 0.872503 | -1.004130 | . 996 0.558091 | 0.376766 | . 997 2.590796 | 0.704992 | . 998 0.594856 | 0.697934 | . 999 0.736059 | -0.764732 | . 1000 rows × 2 columns . sns.scatterplot(data=pd.DataFrame({&#39;x&#39;:x1,&#39;y&#39;:y1}),x=&#39;x&#39;,y=&#39;y&#39;) sns.scatterplot(data=pd.DataFrame({&#39;x&#39;:x2,&#39;y&#39;:y2}),x=&#39;x&#39;,y=&#39;y&#39;) #wide하게 만든 df는 별로 경쟁력이 없음 . &lt;AxesSubplot:xlabel=&#39;x&#39;, ylabel=&#39;y&#39;&gt; . sns: long df . (x1, y1) = (1000, 2) (x2, y2) = (1000, 2) . 이것을 길게 이어 붙일거니까 2000에 2가 만들어져야 함 . . x = np.concatenate([x1, x2]) y = np.concatenate([y1, y2]) cat = [&#39;x&#39;]*len(x1) + [&#39;x2&#39;]*len(x2) . np.array(list(x1) + list(x2)) . array([-0.6499075 , 1.82038047, 0.10065827, ..., 1.00445563, 1.62890094, -0.19747213]) . df2 = pd.DataFrame({&#39;x&#39; : x, &#39;y&#39; : y, &#39;cat&#39; : cat }) df2 . x y cat . 0 -0.649907 | 0.595720 | x | . 1 1.820380 | 0.198625 | x | . 2 0.100658 | 0.239103 | x | . 3 -1.545113 | -0.951085 | x | . 4 0.064387 | -1.128326 | x | . ... ... | ... | ... | . 1995 2.394455 | 1.809380 | x2 | . 1996 2.103812 | 2.438614 | x2 | . 1997 1.004456 | 0.858603 | x2 | . 1998 1.628901 | 2.574994 | x2 | . 1999 -0.197472 | 0.755469 | x2 | . 2000 rows × 3 columns . sns.scatterplot(data = df2, x = &#39;x&#39;, y = &#39;y&#39;, hue = &#39;cat&#39; ) . &lt;AxesSubplot:xlabel=&#39;x&#39;, ylabel=&#39;y&#39;&gt; . sns&#51012; &#51060;&#50857;&#54616;&#50668; matplotlib &#50529;&#49884;&#51592;&#50640; &#44536;&#47548; &#44536;&#47532;&#44592;! &#51473;&#50836; . fig,ax = plt.subplots(1,3,figsize=(12,4)) ax[0].plot([1,2,4,3],&#39;--o&#39;) sns.scatterplot(x=x1,y=y1,ax=ax[1]) #ax1에다가 seaborn으로 그림 #세번째 그림 그리기 sns.scatterplot(x=x1,y=y1,ax=ax[2]) sns.scatterplot(x=x2,y=y2,ax=ax[2]) ax[2].plot([1,2,4,3],&#39;-r&#39;,lw=5) . [&lt;matplotlib.lines.Line2D at 0x7fdb4adb5df0&gt;] . import cv2 !wget https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg #이미지 주소 복사 후 파일 불러오기 img = cv2.imread(&#39;Unequalized_Hawkes_Bay_NZ.jpg&#39;,0) #cv키 임포트 -&gt; 다운받은 파일 img로 저장, 0 : 흑백이미지 생성 !rm Unequalized_Hawkes_Bay_NZ.jpg #저장된 파일이 지워짐 . --2022-10-08 11:06:44-- https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg Resolving upload.wikimedia.org (upload.wikimedia.org)... 103.102.166.240 Connecting to upload.wikimedia.org (upload.wikimedia.org)|103.102.166.240|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 110895 (108K) [image/jpeg] Saving to: &#39;Unequalized_Hawkes_Bay_NZ.jpg&#39; Unequalized_Hawkes_ 100%[===================&gt;] 108.30K 505KB/s in 0.2s 2022-10-08 11:06:44 (505 KB/s) - &#39;Unequalized_Hawkes_Bay_NZ.jpg&#39; saved [110895/110895] . img2 = cv2.equalizeHist(img) . img.reshape(-1) #벡터 생성 . array([127, 145, 149, ..., 146, 145, 144], dtype=uint8) . fig,ax = plt.subplots(2,2,figsize=(10,5)) ax[0,0].imshow(img,vmin=0,vmax=255,cmap=&#39;gray&#39;) #cmap :색 지정 sns.histplot(img.reshape(-1),ax=ax[0,1],bins=15,lw=0,kde=True,color=&#39;C1&#39;) #kde : 곡선 만들어줌 ax[0,1].set_xlim(0,255) #x축 범위 바꾸기(mpl) ax[1,0].imshow(img2,vmin=0,vmax=255,cmap=&#39;gray&#39;) sns.histplot(img2.reshape(-1),ax=ax[1,1],bins=15,lw=0,kde=True,color=&#39;C1&#39;) #kde 선을 보면 플랫해서 값들이 골고루 있는 것을 알 수 있음 . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . &#48120;&#49464;&#47676;&#51648; &#54017;(2) . import matplotlib as mpl . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(3)) # 큰 눈금간격을 3으로 ax.xaxis.set_minor_locator(mpl.ticker.MultipleLocator(1)) # 작은 눈금간격을 1로 . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.xaxis.set_major_locator(mpl.ticker.NullLocator()) # x축 눈금삭제 ax.yaxis.set_major_locator(mpl.ticker.NullLocator()) # y축 눈금삭제 . 축 범위조정 . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.set_ylim(-1,2) ax.set_xlim(-5,35) #plt.ylim(-1,2) 위에랑 같은 코드 #plt.xlim(-5,35) . (-5.0, 35.0) . gcf . plt.plot([1,2,3,2]) fig = plt.gcf() #현재 피규어를 가져와라(뒤늦게라도 코드에 이름을 붙이도록 하려고 등등) . fig.suptitle(&#39;suptitle&#39;) . Text(0.5, 0.98, &#39;suptitle&#39;) . gca - 이름을 붙이고 싶은데 슈퍼 타이틀 말고 axes 이름을 붙이고 싶을 때 사용 . fig . fig . ax = fig.gca() #ax가 피규어 안에 있는 엑시즈에 접근하여 뽑아냄 . ax.set_title(&#39;title&#39;) fig .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/08/sns-scatterplot.html",
            "relUrl": "/python/2022/10/08/sns-scatterplot.html",
            "date": " • Oct 8, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "데이터 시각화 7",
            "content": "import pandas as pd import numpy as np import matplotlib as mpl import seaborn as sns . df1=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/male1.csv&#39;) df2=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/male2.csv&#39;) df3=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/female.csv&#39;) df4=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/foreign.csv&#39;) . _df = pd.concat([pd.concat([df1,df2],axis=1).assign(g=&#39;m&#39;),df3.assign(g=&#39;f&#39;)]) df = pd.concat([_df.assign(g2=&#39;korea&#39;),df4.assign(g2=&#39;foreign&#39;)]).reset_index(drop=True) df #assign(g = &quot;f&quot;) g라는 열을 만들어 &quot;f&quot;라고 만들기 #axis = 1 : 옆으로 붙이기 그냥 붙이면 아래로 붙여짐(axis=0) . w h g g2 . 0 72.788217 | 183.486773 | m | korea | . 1 66.606430 | 173.599877 | m | korea | . 2 69.806324 | 173.237903 | m | korea | . 3 67.449439 | 173.223805 | m | korea | . 4 70.463183 | 174.931946 | m | korea | . ... ... | ... | ... | ... | . 1525 78.154632 | 188.324350 | m | foreign | . 1526 74.754308 | 183.017979 | f | foreign | . 1527 91.196208 | 190.100456 | m | foreign | . 1528 87.770394 | 187.987255 | m | foreign | . 1529 88.021995 | 193.456798 | m | foreign | . 1530 rows × 4 columns . sns.scatterplot(data=df,x=&#39;w&#39;,y=&#39;h&#39;,hue=&#39;g&#39;,style=&#39;g2&#39;) . &lt;AxesSubplot:xlabel=&#39;w&#39;, ylabel=&#39;h&#39;&gt; . #1 기획력 부족 -&gt; 좋은 시각화 많이 볼 것 #2 데이터 프레임에 대한 이해부족-&gt; 타이디 데이터에 대한 개념알기 #3 프로그래밍 능력 -&gt;코딩 공부 열심히 . pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/mpg.csv&#39;) . manufacturer model displ year cyl trans drv cty hwy fl class . 0 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 1 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 2 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 4 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 229 volkswagen | passat | 2.0 | 2008 | 4 | auto(s6) | f | 19 | 28 | p | midsize | . 230 volkswagen | passat | 2.0 | 2008 | 4 | manual(m6) | f | 21 | 29 | p | midsize | . 231 volkswagen | passat | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | midsize | . 232 volkswagen | passat | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | midsize | . 233 volkswagen | passat | 3.6 | 2008 | 6 | auto(s6) | f | 17 | 26 | p | midsize | . 234 rows × 11 columns . displ: 자동차의 엔진크기 . | hwy: 연료의 효율, 동일한 연료로 얼마나 멀리 가느냐? . | 자세한 설명은 R에서 ?mpg를 이용해 스스로 찾아볼 것 . | .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/07/%EB%B3%B4%EC%B6%A9.html",
            "relUrl": "/python/2022/10/07/%EB%B3%B4%EC%B6%A9.html",
            "date": " • Oct 7, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "기후자료 통계분석 코드 분석 과제",
            "content": "import matplotlib.pyplot as plt import xarray as xr #라이브러리 불러오기 dset = xr.open_dataset(‘./Data/sst.mnmean.nc’) #데이터 셋 불러오기. sst=dset.sst.sel() #데이터 셋 중 sst를 선택해서 sst라고 저장 nino34 = sst.where((sst.lat&lt;5) &amp; (sst.lat&gt;-5) &amp; (sst.lon&gt;190) &amp; (sst.lon&lt;240), drop=True).mean(dim=[&#39;lat&#39;,&#39;lon&#39;]) #sst 중 위도가 -5에서 5사이 그리고 경도가 190에서 240 사이에 위치하는 데이터 셋을 고르기, 이 조건을 만족하지 못하는 레이블은 결과에서 삭제하고, 경도와 위도를 평균으로 하는 데이터 셋을 nino34에 저장 clim = nino34.sel(time=slice(‘1982-01&#39;,’2018-12&#39;)).groupby(&#39;time.month&#39;).mean(dim=&#39;time&#39;) #시간을 선택해서 달별로 그룹화, 시간대상 평균을 내고 clim에 저장 anom = (nino34.groupby(&#39;time.month&#39;) - clim).sel(time=slice(‘1981-12&#39;,&#39;2019-02&#39;)) #각 달만큼 그룹화 한 것 - 달마다 평균낸 것 -&gt; 편차를 atom에 저장 nino3mon = anom.rolling(time=5, center=True).mean() #5개월 단위로(롤링)평균 구해서 nino3mon에 저장 ninos = nino3mon[12::12] #달 선택 #그림판 그리기 fig = plt.figure(figsize = (8,6), dpi = 150) ax = fig.subplots() #그림 꾸미기 ax.plot(ninos.time.values, ninos, ‘b-&#39;) ax.axhline(0,color=&#39;black&#39;,linewidth=0.5) # ax.axhline(1.0,color=&#39;black&#39;,linewidth=0.5,linestyle=&#39;dashed&#39;) ax.axhline(-1.0,color=&#39;black&#39;,linewidth=0.5,linestyle=&#39;dashed&#39;) ax.axhline(1.5,color=&#39;black&#39;,linewidth=0.6,linestyle=&#39;dashed&#39;) ax.axhline(-1.5,color=&#39;black&#39;,linewidth=0.6,linestyle=&#39;dashed&#39;) ax.axhline(2.0,color=&#39;black&#39;,linewidth=0.7,linestyle=&#39;dashed&#39;) ax.axhline(-2.0,color=&#39;black&#39;,linewidth=0.7,linestyle=&#39;dashed’) ax.axhline(ninos.std().values,color=&#39;red&#39;,linewidth=0.5,linestyle=&#39;dashed&#39;) #x축 y축 이름 설정 ax.set_xlabel(&#39;Time&#39;) ax.set_ylabel(&#39;[$ degree$C]&#39;) #타이틀 설정하기 ax.set_title(&#39;Nino 3.4 index&#39;) #이미지 저장 plt.savefig(&#39;nino34_index_season.jpg’) plt.show() .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/06/%EA%B8%B0%ED%9B%84%EC%9E%90%EB%A3%8C-%ED%86%B5%EA%B3%84%EB%B6%84%EC%84%9D-%EA%B3%BC%EC%A0%9C.html",
            "relUrl": "/python/2022/10/06/%EA%B8%B0%ED%9B%84%EC%9E%90%EB%A3%8C-%ED%86%B5%EA%B3%84%EB%B6%84%EC%84%9D-%EA%B3%BC%EC%A0%9C.html",
            "date": " • Oct 6, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "데이터 시각화 과제 4",
            "content": "import pandas as pd import numpy as np import seaborn as sns import matplotlib.pyplot as plt . 아래의 그림에 대응하는 그림을 seaborn을 이용하여 그려라 . y1 = np.random.randn(90).cumsum() y2 = np.random.randn(120).cumsum() . plt.plot(y1,&#39;--o&#39;) plt.plot(y2,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fa172cd2b80&gt;] . df = pd.DataFrame({&#39;index&#39; : list(range(90))+list(range(120)), &#39;val&#39; : np.concatenate([y1,y2]), &#39;cat&#39; : [&quot;y1&quot;]*90+[&quot;y2&quot;]*120}) . df . index val cat . 0 0 | 0.512007 | y1 | . 1 1 | 0.836565 | y1 | . 2 2 | 1.040704 | y1 | . 3 3 | 1.397047 | y1 | . 4 4 | 0.765464 | y1 | . ... ... | ... | ... | . 205 115 | -8.820426 | y2 | . 206 116 | -9.655268 | y2 | . 207 117 | -9.507072 | y2 | . 208 118 | -7.630993 | y2 | . 209 119 | -7.234471 | y2 | . 210 rows × 3 columns . sns.lineplot(data = df, x = &quot;index&quot;, y= &quot;val&quot;, hue = &quot;cat&quot;) . &lt;AxesSubplot:xlabel=&#39;index&#39;, ylabel=&#39;val&#39;&gt; . sns.lineplot(data = df, x =&quot;index&quot;, y = &quot;val&quot;, style = &quot;cat&quot;, hue = &quot;cat&quot;, dashes = [(5,1),(9,3)], markers = [&#39;o&#39;,&#39;o&#39;], markersize = 9) . &lt;AxesSubplot:xlabel=&#39;index&#39;, ylabel=&#39;val&#39;&gt; .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/03/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-%EA%B3%BC%EC%A0%9C4.html",
            "relUrl": "/python/2022/10/03/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-%EA%B3%BC%EC%A0%9C4.html",
            "date": " • Oct 3, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "데이터 시각화 5",
            "content": "import seaborn as sns import matplotlib.pyplot as plt import numpy as np import pandas as pd . 데이터프레임 형태는 long form 과 wide form 이 있다. // 참고로 long form이 더 우수한 저장형태에요! . wide-df = [array1,array2,array3] | long-df = [array_val, array_cat] | . 데이터 프레임을 무조건 만들어야 한다. . matplotlib이랑 매우 비슷함. . sns.boxplot . y1=[75,75,76,76,77,77,79,79,79,98] y2=[76,76,77,77,78,78,80,80,80,81] . plt.boxplot([y1, y2]); . sns wide df . df1 = pd.DataFrame({1:y1, 2:y2}) ##만드는 게 진짜 중요 df1 . 1 2 . 0 75 | 76 | . 1 75 | 76 | . 2 76 | 77 | . 3 76 | 77 | . 4 77 | 78 | . 5 77 | 78 | . 6 79 | 80 | . 7 79 | 80 | . 8 79 | 80 | . 9 98 | 81 | . sns.boxplot(data = df1) #y1 y2 알아서 그려줌 . &lt;AxesSubplot:&gt; . sns long df . df2 = pd.DataFrame({&quot;score&quot; : y1+y2, &quot;class&quot; : [&#39;A&#39;]*len(y1)+[&#39;b&#39;]*len(y2)}) . df2 #와이드 폼은 데이터 갯수가 다르면 저장 불가 -&gt; 롱폼이 더 좋음 . score class . 0 75 | A | . 1 75 | A | . 2 76 | A | . 3 76 | A | . 4 77 | A | . 5 77 | A | . 6 79 | A | . 7 79 | A | . 8 79 | A | . 9 98 | A | . 10 76 | b | . 11 76 | b | . 12 77 | b | . 13 77 | b | . 14 78 | b | . 15 78 | b | . 16 80 | b | . 17 80 | b | . 18 80 | b | . 19 81 | b | . sns.boxplot(data=df2,x=&#39;class&#39;,y=&#39;score&#39;) . &lt;AxesSubplot:xlabel=&#39;class&#39;, ylabel=&#39;score&#39;&gt; . sns.array . sns.boxplot(y=y1) #== data=y1 . &lt;AxesSubplot:&gt; . sns.boxplot(x=y1) #x축에 그리면 boxplot이 뒤집어짐!! . &lt;AxesSubplot:&gt; . sns.histplot . x= np.random.randn(10000) y= np.random.randn(10000) +1 . &#48373;&#49845; . plt.hist(x,alpha=0.5) plt.hist(y,alpha=0.5); #alpha == 투명도 . plt.hist([x,y]); . sns: wide df . df1 = pd.DataFrame({&quot;x&quot; : x, &quot;y&quot; : y}) df1 . x y . 0 0.883839 | 0.742332 | . 1 -0.741664 | 0.904649 | . 2 -0.482733 | 0.397702 | . 3 -0.496118 | 2.008637 | . 4 -1.259945 | 3.014091 | . ... ... | ... | . 9995 -0.198176 | 1.094588 | . 9996 -0.004803 | 1.000243 | . 9997 1.214724 | 0.691808 | . 9998 0.343697 | 3.017497 | . 9999 -0.308866 | 2.813727 | . 10000 rows × 2 columns . sns.histplot(data = df1) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . sns.histplot(data=df1,bins=20,kde=True,element=&quot;step&quot;) #element = &quot;step&quot; : 안에 선 없이 예쁘게 그려짐 #kde = 추세선 . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . sns.histplot(data=df1,bins=20,kde=True,element=&quot;step&quot;, lw = 0) #선 굵기 정하기 mpl랑 동일! #선 없앨 때 유용 . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . sns long df . df2=pd.DataFrame({&#39;val&#39;:np.concatenate([x,y]), &#39;var&#39;:[&#39;x&#39;]*len(x) + [&#39;y&#39;]*len(y)}) df2 #리스트가 아니므로 x+y안 됨. np.concatenate사용해서 붙여주기 . val var . 0 0.883839 | x | . 1 -0.741664 | x | . 2 -0.482733 | x | . 3 -0.496118 | x | . 4 -1.259945 | x | . ... ... | ... | . 19995 1.094588 | y | . 19996 1.000243 | y | . 19997 0.691808 | y | . 19998 3.017497 | y | . 19999 2.813727 | y | . 20000 rows × 2 columns . sns.histplot(data=df2,x=&#39;val&#39;,hue=&#39;var&#39;,bins=20,kde=True,lw=0) #hue = &#39;var&#39; -&gt; 색 . &lt;AxesSubplot:xlabel=&#39;val&#39;, ylabel=&#39;Count&#39;&gt; . sns lineplot . np.random.seed(43052) ϵ = np.random.randn(100) . cumsum . sns.histplot(data = x) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . np.cumsum(np.array([1, 2,3])) #누적된 값이 더해짐! . array([1, 3, 6]) . y = np.cumsum(ϵ) #입실론을 다 더한 것 . plt.plot(ϵ,&#39;--o&#39;) #입실론에 대한 그림 . [&lt;matplotlib.lines.Line2D at 0x7ff1e0c86520&gt;] . plt.plot(y,&#39;--o&#39;) #y에 대한 그림 . [&lt;matplotlib.lines.Line2D at 0x7ff22acef0a0&gt;] . sns array . sns.lineplot(data=ϵ) . &lt;AxesSubplot:&gt; . sns.lineplot(data=y) . &lt;AxesSubplot:&gt; . sns wide df . df1 = pd.DataFrame({&quot;epsilon&quot; : ϵ, &quot;y&quot; : y}) df1 . epsilon y . 0 0.383420 | 0.383420 | . 1 1.084175 | 1.467595 | . 2 1.142778 | 2.610373 | . 3 0.307894 | 2.918267 | . 4 0.237787 | 3.156054 | . ... ... | ... | . 95 1.308688 | -10.598788 | . 96 0.405376 | -10.193412 | . 97 -0.185070 | -10.378481 | . 98 1.055388 | -9.323094 | . 99 1.187014 | -8.136079 | . 100 rows × 2 columns . sns.lineplot(data = df1, dashes = False) . &lt;AxesSubplot:&gt; . sns.lineplot(data = df1, dashes = [(3,1),(15,3)], markers = [&quot;o&quot;, &quot;o&quot;]) #대시들 선 간격 바꾸기 . &lt;AxesSubplot:&gt; . sns long df . df2 = pd.DataFrame({&#39;index&#39; : list(range(100))*2, &#39;val&#39; : np.concatenate([ϵ,y]), &#39;cat&#39; : [&quot;eps&quot;]*100+[&quot;y&quot;]*100}) #1~100/1~100 . df2 . index val cat . 0 0 | 0.383420 | eps | . 1 1 | 1.084175 | eps | . 2 2 | 1.142778 | eps | . 3 3 | 0.307894 | eps | . 4 4 | 0.237787 | eps | . ... ... | ... | ... | . 195 95 | -10.598788 | y | . 196 96 | -10.193412 | y | . 197 97 | -10.378481 | y | . 198 98 | -9.323094 | y | . 199 99 | -8.136079 | y | . 200 rows × 3 columns . sns.lineplot(data = df2, x =&quot;index&quot;, y = &quot;val&quot;, hue = &quot;cat&quot;) . &lt;AxesSubplot:xlabel=&#39;index&#39;, ylabel=&#39;val&#39;&gt; . sns.lineplot(data = df2, x =&quot;index&quot;, y = &quot;val&quot;, style = &quot;cat&quot;, hue = &quot;cat&quot;) #스타일이랑 색을 카테고리에 맞게 . &lt;AxesSubplot:xlabel=&#39;index&#39;, ylabel=&#39;val&#39;&gt; . sns scatterplot . np.random.seed(43052) ϵ = np.random.randn(100) y = np.cumsum(ϵ) . ϵ1 = ϵ[:-1] #t-1의 시점, 처음부터 마지막 하나빼고 ϵ2 = ϵ[1:] #t의 시점, 두번째부터 마지막까지 . y1 = y[:-1] #t-1의 시점 y2 = y[1:] #t의 시점 . plt.plot(ϵ1, ϵ2, &#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7ff1e8d9ca90&gt;] . np.corrcoef(ϵ1, ϵ2) #상관관계 0 -&gt; 독립 . array([[1. , 0.05289696], [0.05289696, 1. ]]) . plt.plot(y1, y2, &#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7ff22b725f10&gt;] . np.corrcoef(y1, y2) #독립아님 . array([[1. , 0.97237553], [0.97237553, 1. ]]) . . y1 = np.random.randn(90).cumsum() y2 = np.random.randn(120).cumsum() . plt.plot(y1,&#39;--o&#39;) plt.plot(y2,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7ff208a5ca30&gt;] . sns.histplot(x = x) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/03/seaborn.html",
            "relUrl": "/python/2022/10/03/seaborn.html",
            "date": " • Oct 3, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "빅데이터 개론 복습 2",
            "content": "3-1 &#49707;&#51088; . import math import sys . type(8) . int . type(8.0) . float . x = 1 y = 3 . x/y . type(x/y) . float . 소수점 17 자리 이상의 아주 작은 실수는 정확하게 숫자의 값을 저장하지 못한다. . 1/3 + 0.0000000000000001 # 소수점 16자리 부동소수점 . 0.3333333333333334 . 1/3 == (1/3 + 0.0000000000000001) # 소수점 17자리 부동소수점 . False . 1/3 == (1/3 + 0.00000000000000001) #소수점 17개 이상은 컴퓨터에서 받아주지 못하는 모습 . True . 0.55 - 0.54 . 0.010000000000000009 . 두 수의 차이 값이 우리가 생각하는 결과와 다를 수 있다. . 0.55 - 0.54 == 0.01 . False . 파이썬이 대수적으로 구별할 수 있는 가장 작은 수는 2.220446049250313e-16 이다. . 엡실론(Machine epsilon)이라고 부르며 파이썬의 계산 엡실론은 sys.float_info.epsilon 으로 알 수 있다. . machine_epsilon = sys.float_info.epsilon machine_epsilon . 2.220446049250313e-16 . 파이썬에서 큰 수를 출력해주는 경우 과학적 표기법(scientific notation)을 사용한다. 아래 식에서 2.0e+306는 2.0×10306 을 의미한다. 큰 수 2.0×10308 은 파이썬의 부동소수점 형식으로 저장할 수 없기 때문에 결과를 inf 로 나타낸다. . 2.0e+306 #2.0×10의306제곱 . 2e+306 . 2.0e306 * 100 . inf . 3-2 &#47928;&#51088;&#50676; . name_3 = &quot;이철수&quot; name_3[0] . &#39;이&#39; . name_3[1:3] . &#39;철수&#39; . text_5 = &#39;There is a desk&#39; text_5 . &#39;There is a desk&#39; . text_5.replace(&quot;is&quot;, &quot;was&quot;) #문자열 따옴표 잊지 말기 . &#39;There was a desk&#39; . text_5.upper() # 문자열을 모두 대문자로 . &#39;THERE IS A DESK&#39; . text_5.count(&#39;e&#39;) # 괄호안에 주어진 문자열이 몇 번 나타나는지 . 3 . text_5.split(sep=&#39; &#39;) # sep= 으로 지정된 문자열을 사용하여 문자열을 나누어서 리스트로 저장 . [&#39;There&#39;, &#39;is&#39;, &#39;a&#39;, &#39;desk&#39;] . &#49892;&#49845; . 본인의 단대, 학과, 학번, 이름(영문)을 각각 문자열로 정의하여라. 정의된 문자열을 하나로 결합하여라. . | 위에서 정의된 본인의 이름을 모두 대문자로 바꾸어라. . | 위에서 결합된 문자열에서 본인의 이름을 국문으로 바꾸어라. . | 본인의 생년월일을 다음과 같은 형식으로 표기하는 문자열을 정의하여라. 1990/02/16 . | 생년월일에서 년에 해당하는 정보만을 추출하여라. . | 생년월일을 년, 월, 일 새 부분으로 나누어라. . | a = &quot;인문대&quot; b = &quot;스페인중남미학과&quot; c = &quot;201821502&quot; d = &quot;Hyeji&quot; aa = a +&quot; &quot;+ b +&quot; &quot;+ c +&quot; &quot;+ d aa . &#39;인문대 스페인중남미학과 201821502 Hyeji&#39; . d.upper() . &#39;HYEJI&#39; . aa.replace(d, &quot;혜지&quot;) . &#39;인문대 스페인중남미학과 201821502 혜지&#39; . e = &quot;1000/02/01&quot; . e[5:7] . &#39;02&#39; . e[0:4] . &#39;1000&#39; . e.split(&quot;/&quot;) . [&#39;1000&#39;, &#39;02&#39;, &#39;01&#39;] . f1, f2, f3 = e.split(sep = &quot;/&quot;) f2 . &#39;02&#39; . &#54665;&#47148;(array) . 이 과목에서는 행렬 형식보다 데이터프레임 형식의 자료를 주로 이용한다. 이 장에서는 라이브러리 numpy 에서 제공하는 행렬의 간단한 사용법만 살펴볼것이다. . import numpy as np . a = np.array([1,2,3,4,5,6]) a . array([1, 2, 3, 4, 5, 6]) . 행렬은 리스트와 달리 같은 형식의 자료만 모아 놓을 수 있다. . np.array([1, 2, &#39;a&#39;]) #정의 안 됨 -&gt; 같은 형식으로만 실행하기 . array([&#39;1&#39;, &#39;2&#39;, &#39;a&#39;], dtype=&#39;&lt;U21&#39;) . a[0] . 1 . a[[0, 3, 5]] #행렬은 다음과 같이 순서의 위치를 []에 넣어서 부를 수 있음 . array([1, 4, 6]) . a[0:3] . array([1, 2, 3]) . . np.arange(6) . array([0, 1, 2, 3, 4, 5]) . np.arange(2, 10, 2) #짝수 . array([2, 4, 6, 8]) . np.arange(0, 10, 3) #0포함 3의 배수 . array([0, 3, 6, 9]) . np.arange(10, -10, -2) . array([10, 8, 6, 4, 2, 0, -2, -4, -6, -8]) . 2차원 행렬 - reshape() . b = np.arange(1, 9).reshape(2, 4) b . array([[1, 2, 3, 4], [5, 6, 7, 8]]) . c = np.array([[1, 2, 3, 4], [5, 6, 7, 8]]) c . array([[1, 2, 3, 4], [5, 6, 7, 8]]) . b[0,0] #2차원에서 일부를 지정해 보는 법 . 1 . b[0, 0:4] #1행, 1-4열 . array([1, 2, 3, 4]) . b[0:2, 1:3] . array([[2, 3], [6, 7]]) . c = b[0:2,1] #열이 하나밖에 없으므로 일차원 배열로 보여줌!!!!!!! c . array([2, 6]) . c.ndim . 1 . c_1 = c.reshape(2,1) #2차원으로 바꾸기 c_1 . array([[2], [6]]) . d = b[1, 0:3] d . array([5, 6, 7]) . d.ndim . 1 . &#47928;&#51228; . 다음과 같은 코드를 먼저 실행하고 물음에 답하여라 . A = np.array([1, 4, 2, 5, 3]) . 1) A의 1, 3, 5 번째 원소를 추출하여라 2) A의 마지막 원소만 제외한 나머지로 이루어진 1차원 배열을 추출하여라 3) 5에서 1씩 감소하는 길이가 5인 1차원 배열을 만들고 B라 명명하여라 4) A와 B를 순서대로 연결하는 1차원 배열 C를 만들어라(concatenate([x,y])이용) 5) 위에서 만들어진 C로부터 A가 첫번째 행, B를 두번째 행이 되도록 2차원 배열(행렬) D를 정의 하여라 6) D의 첫 두번째 행과 첫 두번째 열로 이루어진 부분행렬을 추출하여라 7) D의 세 번째 열로만 이루어진 배열을 추출하여라. 단, 1차원 배열이 아니라 2차원 배열의 속성을 그대로 가지도록 하여라 . import numpy as np . A = np.array([1, 4, 2, 5, 3]) . A[[0,2,4]] #1 . array([1, 2, 3]) . A[0:4] . array([1, 4, 2, 5]) . B = np.arange(5, 0, -1) B . array([5, 4, 3, 2, 1]) . C = np.concatenate([A,B]) C . array([1, 4, 2, 5, 3, 5, 4, 3, 2, 1]) . D = C.reshape(2, 5) #2행 5열 인것을 잊지말기 행만 2개가 아닌 열도 신경써야함 D . array([[1, 4, 2, 5, 3], [5, 4, 3, 2, 1]]) . D[0:2, 0:2] . array([[1, 4], [5, 4]]) . D[:,2].reshape(2,1) #리솊을 해서 2차원으로 만들기 . array([[2], [3]]) .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/10/02/(%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%9C%EB%A1%A0-3-1~3-3).html",
            "relUrl": "/python/2022/10/02/(%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%9C%EB%A1%A0-3-1~3-3).html",
            "date": " • Oct 2, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "빅데이터 개론 복습1",
            "content": "2-1 &#54364;&#54788;&#49885;&#44284; &#48320;&#49688; . hour_rate = 10000 month_working_days = 20 day_working_hours = 4 month_pay = hour_rate * month_working_days * day_working_hours month_pay . 800000 . text_2 =&#39;you can &#39;t come&#39; #역슬래시로 구분하기 text_2 . &#34;you can&#39;t come&#34; . print(&quot;첫 번째 줄 n두 번째 줄&quot;) . 첫 번째 줄 두 번째 줄 . text_4 = &#39;C: some name&#39; print(text_4) . C: some ame . text_5 = r&#39;C: some name&#39; print(text_5) . C: some name . 라이브러리와 함수 | . import math . math.sin(2) . 0.9092974268256817 . math.log(100) . 4.605170185988092 . 리스트 | . list_1 = [1, 2, 0.5, &#39;chair&#39;] list_1 . [1, 2, 0.5, &#39;chair&#39;] . list_2 = [ list_1, &quot;A&quot;, [1,2,3] ] list_2 . [[1, 2, 0.5, &#39;chair&#39;], &#39;A&#39;, [1, 2, 3]] . 파이썬의 인덱스는 1이 아닌 0 부터 시작하므로 이를 언제나 유념해야 한다 . squares = [1, 4, 9, 16, 25] . squares[0] . 1 . squares[4] . 25 . squares[:1] . [1] . squares[:-1] . [1, 4, 9, 16] . squares[-1:] . [25] . 1 in [1, 2, 3, 4] . True . a = 5 a in [1, 2, 3, 4, 5] . True . &#49892;&#49845; . hstudent.csv&#39;는 20명의 고등학생 성별, 학년, 키(cm), 몸무게(kg)를 조사한 자료이다. | 체질량지수는 몸무게(kg)를 키의 제곱(m)으로 나눈 값입니다. 5번 학생의 체질량지수는? | 10번 학생의 체질량지수는? | . | 학생의 키와 몸무게를 각각 height와 weight에 저장하고, height와 weight를 사용하여 체질량지수 계산 5번 과 10번 학생 각각에 대하여 계산한 후 bmi5와 bmi10에 저장 | bmi5와 bmi10의 크기 비교 결과 print함수를 사용하여 보여주기 | . | 1번부터 5번까지의 학생 키를 원소로 가지는 리스트 변수 height1_5생성 1번부터 3번까지 학생의 키 추출 | . | . 나는 전북대학교 학과 이름 입니다. (예, 나는 전북대학교 통계학과 최혜미입니다) 위 문자열을 값으로 가지는 변수 name_dept를 생성 | 변수 name_dept에서 전북대학교 추출 | . | df = pd.read_csv(&quot;hstudent.csv&quot;) df . gender grade height weight . 0 1 | 3 | 183 | 82 | . 1 2 | 1 | 168 | 52 | . 2 2 | 1 | 160 | 48 | . 3 2 | 2 | 160 | 50 | . 4 1 | 1 | 160 | 79 | . 5 1 | 2 | 180 | 73 | . 6 2 | 2 | 183 | 60 | . 7 1 | 1 | 170 | 66 | . 8 1 | 3 | 170 | 74 | . 9 1 | 3 | 185 | 57 | . 10 1 | 2 | 165 | 54 | . 11 2 | 1 | 170 | 50 | . 12 2 | 1 | 152 | 60 | . 13 2 | 3 | 173 | 63 | . 14 1 | 1 | 145 | 57 | . 15 1 | 3 | 163 | 77 | . 16 2 | 2 | 178 | 50 | . 17 2 | 2 | 163 | 57 | . 18 2 | 2 | 168 | 54 | . 19 2 | 3 | 170 | 57 | . height = df[&#39;height&#39;] weight = df[&#39;weight&#39;] . bmi5 = weight[4]/height[4]**2 bmi10 = weight[9]/height[9]**2 print(bmi5, bmi10) . 0.0030859375 0.0016654492330168006 . height1_5 = height[0:5] height1_5[0:3] . 0 183 1 168 2 160 Name: height, dtype: int64 . height1_5 = list(height[0:5]) height1_5[0:3] . [183, 168, 160] . # weight = [82, 52, 48, 50, 79, 73, 60, 66, 74, 57, 54, 50, 60, 63, 57, 77, 50, 57, 54, 57] . name_debt = &quot;나는 전북대학교 스페인중남미학과 김혜지입니다.&quot; name_debt[3:8] . &#39;전북대학교&#39; . 2-2 &#54032;&#45796;&#49828; &#45936;&#51060;&#53552; &#54532;&#47112;&#51076; . import pandas as pd . df = pd.DataFrame({ &#39;name&#39; : [&#39;이철수&#39;, &#39;김영희&#39;, &#39;홍길동&#39;, &#39;John Smith&#39;], &#39;sex&#39; : [&#39;M&#39;, &#39;F&#39;, &#39;M&#39;, &#39;M&#39;], &#39;age&#39; : [23, 25, 21, 33] }) . df . name sex age . 0 이철수 | M | 23 | . 1 김영희 | F | 25 | . 2 홍길동 | M | 21 | . 3 John Smith | M | 33 | . 슬라이싱 | . df[[&#39;name&#39;, &#39;age&#39;]] #두 개 이상의 열을 슬라이싱 하기위해서는 리스트를 사용하기 . name age . 0 이철수 | 23 | . 1 김영희 | 25 | . 2 홍길동 | 21 | . 3 John Smith | 33 | . #데이터 프레임 열을 슬라이스 하는 경우는 마침표 사용해서 슬라이싱이 가능 df.age . 0 23 1 25 2 21 3 33 Name: age, dtype: int64 . df[df[&#39;age&#39;] &gt;= 25] #df[&#39;age&#39;] &gt;= 25는 참, 거짓으로 구성된 시리즈 -&gt; 슬라이싱 하기 위해서는 df을 한 번 더 씌어주면 됨 . name sex age . 1 김영희 | F | 25 | . 3 John Smith | M | 33 | . 데이터 프레임 메소드 | . df.describe() #describe() : 숫자로 구성된 열의 기초 통계량을 구하는 표현식 . age . count 4.000000 | . mean 25.500000 | . std 5.259911 | . min 21.000000 | . 25% 22.500000 | . 50% 24.000000 | . 75% 27.000000 | . max 33.000000 | . df.max() #각 열의 최대값을 구하는 작업을 수행 ?왜 맥스 값을 찍었는데 홍길동 이름이 나오지? #한글은 가나다순, 영어는 알파벳 순으로 max값이 뽑힌다. . name 홍길동 sex M age 33 dtype: object . df.shape . (4, 3) . df.iloc[1,0] . &#39;김영희&#39; . df.iloc[2,2] . 21 . &#47928;&#51228;1 . 사진과 같은 데이터 프레임 만들기 | 데이터 프레임의 shape를 출력 | 평균 면적(area)을 계산하여라 | 인구수가 2000만명 이하인 주들을 골라내어라. 또한 해당하는 주의 평균 밀도를 구해보아라 | 첫 3개의 행과 첫 2개의 열로 이루어진 sub-dataframe을 추출하여라 | New York의 인구(pop)를 추출하여라 | df = pd.DataFrame({&quot;area&quot; : [423967, 695662, 141297, 170312, 149995], &quot;pop1&quot; : [38332521, 26448193, 19651127, 19552860, 12882135], &quot;density&quot; : [90.000000, 38.018740, 139.076746, 114.806121, 85.883763] }, index = [&quot;Califonia&quot;, &quot;Texas&quot;, &quot;New York&quot;, &quot;Flprida&quot;, &quot;Illinois&quot;]) df . area pop1 density . Califonia 423967 | 38332521 | 90.000000 | . Texas 695662 | 26448193 | 38.018740 | . New York 141297 | 19651127 | 139.076746 | . Flprida 170312 | 19552860 | 114.806121 | . Illinois 149995 | 12882135 | 85.883763 | . df.shape . (5, 3) . df[&quot;area&quot;].mean() #mean다음에 괄호 잊지 말기 () 중요!! . 316246.6 . df[df[&quot;pop1&quot;] &lt;= 20000000][&quot;density&quot;].mean() #mean() 다음에 괄호 필수, 데이터 프레임 옆에 붙여서 밀도의 평균 계산 가능 . 113.25554333333334 . df.iloc[:3,:2] # iloc 사용하기 . area pop1 . Califonia 423967 | 38332521 | . Texas 695662 | 26448193 | . New York 141297 | 19651127 | . df.iloc[2,1] . 19651127 . df[&quot;pop1&quot;][&quot;New York&quot;] # df를 뽑으려면 무조건 열 먼저 실행 후 행 선택하기(행 먼저하면 오류 발생) . 19651127 . 2-3 &#44256;&#49549;&#50676;&#52264; &#50668;&#44061; &#49688;&#49569;&#51088;&#47308; . import pandas as pd import matplotlib.pyplot as plt from matplotlib import rc %matplotlib inline rc(&#39;font&#39;, family=&#39;AppleGothic&#39;) plt.rcParams[&#39;axes.unicode_minus&#39;] = False plt.rcParams[&quot;figure.figsize&quot;] = (10,5) . url =&quot;https://ilovedata.github.io/teaching/bigdata2/data/train-data-01.csv&quot; train_raw_data = pd.read_csv(url) train_raw_data . TRAIN_NO DATE STATION_DEPART STATION_ARRV NUM_PASSENGER . 0 2 | 20190701 | 서울 | 대전 | 106.0 | . 1 2 | 20190702 | 서울 | 대전 | 113.0 | . 2 2 | 20190703 | 서울 | 대전 | 146.0 | . 3 2 | 20190704 | 서울 | 대전 | 84.0 | . 4 2 | 20190705 | 서울 | 대전 | 105.0 | . ... ... | ... | ... | ... | ... | . 1764 6 | 20190726 | 울산 | 부산 | 10.0 | . 1765 6 | 20190727 | 울산 | 부산 | 6.0 | . 1766 6 | 20190728 | 울산 | 부산 | 21.0 | . 1767 6 | 20190729 | 울산 | 부산 | 12.0 | . 1768 6 | 20190730 | 울산 | 부산 | 11.0 | . 1769 rows × 5 columns . num_train = train_raw_data[&quot;TRAIN_NO&quot;].unique() num_train . array([2, 5, 6]) . 다음 3개의 조건을 모두 만족하는 행들을 추출 . 열차번호가 2번이다. . 출발역은 서울역이다. . 도착역은 부산역이다. . a = train_raw_data[&quot;TRAIN_NO&quot;] == 2 b = train_raw_data[&quot;STATION_DEPART&quot;] == &quot;서울&quot; c = train_raw_data[&quot;STATION_ARRV&quot;] == &quot;부산&quot; d = a &amp; b &amp; c d . 0 False 1 False 2 False 3 False 4 False ... 1764 False 1765 False 1766 False 1767 False 1768 False Length: 1769, dtype: bool . train2 = train_raw_data[d] #습관처럼 df에 넣지 말자 정의된 데이터 프레임에 넣어야 한다. df[a] 이렇게 표현할 수 있는 이유는 df가 정의되어 있는 데이터 프레임이기 때문이다. . train2 . TRAIN_NO DATE STATION_DEPART STATION_ARRV NUM_PASSENGER . 60 2 | 20190701 | 서울 | 부산 | 613.0 | . 61 2 | 20190702 | 서울 | 부산 | 546.0 | . 62 2 | 20190703 | 서울 | 부산 | 492.0 | . 63 2 | 20190704 | 서울 | 부산 | 615.0 | . 64 2 | 20190705 | 서울 | 부산 | 572.0 | . 65 2 | 20190706 | 서울 | 부산 | 598.0 | . 66 2 | 20190707 | 서울 | 부산 | 326.0 | . 67 2 | 20190708 | 서울 | 부산 | 552.0 | . 68 2 | 20190709 | 서울 | 부산 | 540.0 | . 69 2 | 20190710 | 서울 | 부산 | 499.0 | . 70 2 | 20190711 | 서울 | 부산 | 562.0 | . 71 2 | 20190712 | 서울 | 부산 | 601.0 | . 72 2 | 20190713 | 서울 | 부산 | 655.0 | . 73 2 | 20190714 | 서울 | 부산 | 371.0 | . 74 2 | 20190715 | 서울 | 부산 | 557.0 | . 75 2 | 20190716 | 서울 | 부산 | 525.0 | . 76 2 | 20190717 | 서울 | 부산 | 557.0 | . 77 2 | 20190718 | 서울 | 부산 | 585.0 | . 78 2 | 20190719 | 서울 | 부산 | 593.0 | . 79 2 | 20190720 | 서울 | 부산 | 620.0 | . 80 2 | 20190721 | 서울 | 부산 | 355.0 | . 81 2 | 20190722 | 서울 | 부산 | 548.0 | . 82 2 | 20190723 | 서울 | 부산 | 557.0 | . 83 2 | 20190724 | 서울 | 부산 | 550.0 | . 84 2 | 20190725 | 서울 | 부산 | 593.0 | . 85 2 | 20190726 | 서울 | 부산 | 551.0 | . 86 2 | 20190727 | 서울 | 부산 | 615.0 | . 87 2 | 20190728 | 서울 | 부산 | 530.0 | . 88 2 | 20190729 | 서울 | 부산 | 589.0 | . 89 2 | 20190730 | 서울 | 부산 | 503.0 | . train2.plot(x=&#39;DATE&#39;, y=&quot;NUM_PASSENGER&quot;) #날짜별 승객데이터 확인 가능 . &lt;AxesSubplot:xlabel=&#39;DATE&#39;&gt; . to_datetime() :날짜 형식 변환 ex)format=&#39;%Y%m%d&#39; . train2[&#39;DATE2&#39;] = pd.to_datetime(train2[&#39;DATE&#39;], format=&#39;%Y%m%d&#39;) train2 . /var/folders/xh/xtwkcbrj0_l1srsb4r5pc3l00000gn/T/ipykernel_31932/279216404.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy train2[&#39;DATE2&#39;] = pd.to_datetime(train2[&#39;DATE&#39;], format=&#39;%Y%m%d&#39;) . TRAIN_NO DATE STATION_DEPART STATION_ARRV NUM_PASSENGER DATE2 . 60 2 | 20190701 | 서울 | 부산 | 613.0 | 2019-07-01 | . 61 2 | 20190702 | 서울 | 부산 | 546.0 | 2019-07-02 | . 62 2 | 20190703 | 서울 | 부산 | 492.0 | 2019-07-03 | . 63 2 | 20190704 | 서울 | 부산 | 615.0 | 2019-07-04 | . 64 2 | 20190705 | 서울 | 부산 | 572.0 | 2019-07-05 | . 65 2 | 20190706 | 서울 | 부산 | 598.0 | 2019-07-06 | . 66 2 | 20190707 | 서울 | 부산 | 326.0 | 2019-07-07 | . 67 2 | 20190708 | 서울 | 부산 | 552.0 | 2019-07-08 | . 68 2 | 20190709 | 서울 | 부산 | 540.0 | 2019-07-09 | . 69 2 | 20190710 | 서울 | 부산 | 499.0 | 2019-07-10 | . 70 2 | 20190711 | 서울 | 부산 | 562.0 | 2019-07-11 | . 71 2 | 20190712 | 서울 | 부산 | 601.0 | 2019-07-12 | . 72 2 | 20190713 | 서울 | 부산 | 655.0 | 2019-07-13 | . 73 2 | 20190714 | 서울 | 부산 | 371.0 | 2019-07-14 | . 74 2 | 20190715 | 서울 | 부산 | 557.0 | 2019-07-15 | . 75 2 | 20190716 | 서울 | 부산 | 525.0 | 2019-07-16 | . 76 2 | 20190717 | 서울 | 부산 | 557.0 | 2019-07-17 | . 77 2 | 20190718 | 서울 | 부산 | 585.0 | 2019-07-18 | . 78 2 | 20190719 | 서울 | 부산 | 593.0 | 2019-07-19 | . 79 2 | 20190720 | 서울 | 부산 | 620.0 | 2019-07-20 | . 80 2 | 20190721 | 서울 | 부산 | 355.0 | 2019-07-21 | . 81 2 | 20190722 | 서울 | 부산 | 548.0 | 2019-07-22 | . 82 2 | 20190723 | 서울 | 부산 | 557.0 | 2019-07-23 | . 83 2 | 20190724 | 서울 | 부산 | 550.0 | 2019-07-24 | . 84 2 | 20190725 | 서울 | 부산 | 593.0 | 2019-07-25 | . 85 2 | 20190726 | 서울 | 부산 | 551.0 | 2019-07-26 | . 86 2 | 20190727 | 서울 | 부산 | 615.0 | 2019-07-27 | . 87 2 | 20190728 | 서울 | 부산 | 530.0 | 2019-07-28 | . 88 2 | 20190729 | 서울 | 부산 | 589.0 | 2019-07-29 | . 89 2 | 20190730 | 서울 | 부산 | 503.0 | 2019-07-30 | . train2.plot(x=&#39;DATE2&#39;, y=&quot;NUM_PASSENGER&quot;); . &#44536;&#47353;&#48324; &#48516;&#49437; . . train_raw_data[&#39;DATE2&#39;] = pd.to_datetime(train_raw_data[&#39;DATE&#39;], format=&#39;%Y%m%d&#39;) train_raw_data . TRAIN_NO DATE STATION_DEPART STATION_ARRV NUM_PASSENGER DATE2 . 0 2 | 20190701 | 서울 | 대전 | 106.0 | 2019-07-01 | . 1 2 | 20190702 | 서울 | 대전 | 113.0 | 2019-07-02 | . 2 2 | 20190703 | 서울 | 대전 | 146.0 | 2019-07-03 | . 3 2 | 20190704 | 서울 | 대전 | 84.0 | 2019-07-04 | . 4 2 | 20190705 | 서울 | 대전 | 105.0 | 2019-07-05 | . ... ... | ... | ... | ... | ... | ... | . 1764 6 | 20190726 | 울산 | 부산 | 10.0 | 2019-07-26 | . 1765 6 | 20190727 | 울산 | 부산 | 6.0 | 2019-07-27 | . 1766 6 | 20190728 | 울산 | 부산 | 21.0 | 2019-07-28 | . 1767 6 | 20190729 | 울산 | 부산 | 12.0 | 2019-07-29 | . 1768 6 | 20190730 | 울산 | 부산 | 11.0 | 2019-07-30 | . 1769 rows × 6 columns . 이제 날짜의 형식을 가진 변수 DATE2 를 아용하여 요일을 나타내는 새로운 변수 DAYOFWEEK 를 만들어 보자. .dt.dayofweek 를 적용하면 각 날짜에 대응하는 요일을 구해준다. . train_raw_data[&quot;DAYOFWEEK&quot;] = train_raw_data[&#39;DATE2&#39;].dt.dayofweek . 요일별, 구간별로 탑승객 수의 평균을 구하기 위하여 필요한 변수를 가진 데이터프레임을 먼저 만든다. . 요일별, 구간별 분석을 하려면 다음과 같은 3개의 변수(요일, 출발역, 도착역)로 자료를 그룹화(grouping)해야한다. . train_groub_data = train_raw_data[[&#39;STATION_DEPART&#39;, &#39;STATION_ARRV&#39;,&#39;DAYOFWEEK&#39;,&#39;NUM_PASSENGER&#39;]] . summary_data = train_raw_data.groupby([&#39;STATION_DEPART&#39;,&#39;STATION_ARRV&#39;,&#39;DAYOFWEEK&#39;]).mean() summary_data . TRAIN_NO DATE NUM_PASSENGER . STATION_DEPART STATION_ARRV DAYOFWEEK . 광명 대전 0 5.5 | 20190715.0 | 16.300 | . 1 5.5 | 20190716.0 | 15.200 | . 2 5.5 | 20190713.5 | 20.750 | . 3 5.5 | 20190714.5 | 21.125 | . 4 5.5 | 20190715.5 | 18.125 | . ... ... ... ... | ... | ... | . 행신 서울 2 2.0 | 20190713.5 | 12.750 | . 3 2.0 | 20190714.5 | 10.000 | . 4 2.0 | 20190715.5 | 8.250 | . 5 2.0 | 20190716.5 | 7.500 | . 6 2.0 | 20190717.5 | 5.000 | . 224 rows × 3 columns . 위의 그룹화 결과 자료는 다루기가 까다로와서 각 그룹에 대한 값을 열로 다시 만들어 주는 것이 좋다. . reset_index()사용, inplace=True 은 실제로 데이터프레임에 적용하라는 의미 . summary_data.reset_index(inplace=True) summary_data . STATION_DEPART STATION_ARRV DAYOFWEEK TRAIN_NO DATE NUM_PASSENGER . 0 광명 | 대전 | 0 | 5.5 | 20190715.0 | 16.300 | . 1 광명 | 대전 | 1 | 5.5 | 20190716.0 | 15.200 | . 2 광명 | 대전 | 2 | 5.5 | 20190713.5 | 20.750 | . 3 광명 | 대전 | 3 | 5.5 | 20190714.5 | 21.125 | . 4 광명 | 대전 | 4 | 5.5 | 20190715.5 | 18.125 | . ... ... | ... | ... | ... | ... | ... | . 219 행신 | 서울 | 2 | 2.0 | 20190713.5 | 12.750 | . 220 행신 | 서울 | 3 | 2.0 | 20190714.5 | 10.000 | . 221 행신 | 서울 | 4 | 2.0 | 20190715.5 | 8.250 | . 222 행신 | 서울 | 5 | 2.0 | 20190716.5 | 7.500 | . 223 행신 | 서울 | 6 | 2.0 | 20190717.5 | 5.000 | . 224 rows × 6 columns . 이제 원하는 출발역과 도착역을 선택하여 요일별 평균 탑승객 수를 살펴보자. . od_average = summary_data[ ( summary_data[&#39;STATION_DEPART&#39;] == &#39;서울&#39; ) &amp; ( summary_data[&#39;STATION_ARRV&#39;] == &#39;부산&#39; )] od_average . STATION_DEPART STATION_ARRV DAYOFWEEK TRAIN_NO DATE NUM_PASSENGER . 98 서울 | 부산 | 0 | 4.333333 | 20190715.0 | 284.800000 | . 99 서울 | 부산 | 1 | 4.333333 | 20190716.0 | 284.266667 | . 100 서울 | 부산 | 2 | 4.333333 | 20190713.5 | 287.833333 | . 101 서울 | 부산 | 3 | 4.333333 | 20190714.5 | 319.500000 | . 102 서울 | 부산 | 4 | 4.333333 | 20190715.5 | 353.833333 | . 103 서울 | 부산 | 5 | 4.333333 | 20190716.5 | 311.166667 | . 104 서울 | 부산 | 6 | 4.333333 | 20190717.5 | 265.083333 | . od_average.plot(x = &quot;DAYOFWEEK&quot;, y = &quot;NUM_PASSENGER&quot;); . 2-4 &#50612;&#47536;&#50773;&#51088; . import matplotlib.pyplot as plt from matplotlib import rc plt.rcParams[&#39;axes.unicode_minus&#39;] = False plt.rcParams[&quot;figure.figsize&quot;] = (10,5) import numpy as np import pandas as pd . import base64 import requests url_data =&quot;https://ilovedata.github.io/teaching/bigdata2/data/little-prince.txt&quot; little_prince = requests.get(url_data) little_prince = little_prince.text . little_prince[:1000] . &#39; r n 어린 왕자 r n 영어동화 (우리말 해석) r n 생텍쥐페리 r n r n r n 헌사(받치는 글) r n 레옹 베르트에게 r n r n 먼저 이 글을 어린이들이 아닌 어른들에게 바치는 것에 대해 사과할까 한다. 심심한 사과의 말을 전한다. 하지만 이들 어른들은 세상에서 가장 좋은 친구다. 물론 이 발언에 대해서도 심심한 사과의 말을 전하는 바이다. 이들 어른들은 모든 걸 이해할 수 있다, 심지어 어린이들의 책까지. 이런 세 번째로 사과의 말을 전하는 바이다. 이들 어른들은 프랑스에만 해도 굶 주림과 추위에 살고 있다. 그에겐 아늑함이 필요한 것도 사실이다. 내 사과들이 충분하든 아니든, 난 이 책을 어른이 된 어린이들에게 바치는 바이다. 모든 어른도 출발은 아이들이었다. 하지만 그들 몇몇만 그걸 기억해낼 뿐이다. 그래 내 헌사(받 치는 글)를 다음과 같이 수정할까 한다. r n 어린이였을 때의 r n 레옹 베르트에게 r n r n ※ 지금부터는 『어린 왕자』(생텍쥐페리의 동화)를 해석해보겠습니다. r n r n 이 동화는 아래 링크의 동화를 우리말로 옮긴 것입니다. r n (번역과정에서 구글 번역기를 이용해 1차로 영어원문으로 만든 다음, 그걸 우리말로 읽을 수 있게 좀 수정하고 다듬은 후, 2차로 우리말로 해석했습니다. 따라서 프랑스어 원문과 다를 수 있습니다. 하지만 성실히 번역했기에 큰 줄거리는 맞다고 생각됩니다. 완전한 해석은 아니라는 점 감안해주시고 읽어주세용~♥ 어린 왕자가 좋아서 해석해본 거예요, 제가 읽으려고요. 그러니 많이 읽어주세요~) r n r n 『어린 왕자』(호주의 애들레이드대학교의 인터넷도서관 사이트)(프랑스 원문) ▶ https://ebooks.adelaide.edu.au/s/saint- exupery/antoine_de/le-petit-prince/ (검색 일자 : 2017-12-9) r n r n r n r n Le Petit Prince r n Le Petit Prince / Antoine de &#39; . type(little_prince) . str . np.char.count(자료, 찾고자 하는 문자열) : 문자열 변수안에 지정된 문자열이 몇 번 나타나는지 세어주는 함수 . np.char.count(little_prince, &quot;별&quot;) . array(159) . &#53581;&#49828;&#53944; &#45208;&#45572;&#44592; . mychar = &quot;폭넓은 교양과 심오한 학문적 이론 및 창의적 전문기술을 지닌 지성인을 기른다. 성실한 근면을 바탕으로 책임과 의무를 다하는 건전한 인격을 갖춘 민주 시민을 기른다.&quot; mychar . &#39;폭넓은 교양과 심오한 학문적 이론 및 창의적 전문기술을 지닌 지성인을 기른다. 성실한 근면을 바탕으로 책임과 의무를 다하는 건전한 인격을 갖춘 민주 시민을 기른다.&#39; . mychar.split(&quot;을&quot;) . [&#39;폭넓은 교양과 심오한 학문적 이론 및 창의적 전문기술&#39;, &#39; 지닌 지성인&#39;, &#39; 기른다. 성실한 근면&#39;, &#39; 바탕으로 책임과 의무를 다하는 건전한 인격&#39;, &#39; 갖춘 민주 시민&#39;, &#39; 기른다.&#39;] . little_prince_chapters = little_prince.split(&#39;어린 왕자 r n&#39;) . little_prince_chapters . final = pd.DataFrame({&quot;chapters&quot; : little_prince_chapters}) final . chapters . 0 r n | . 1 영어동화 (우리말 해석) r n 생텍쥐페리 r n r n r n... | . 2 r n 물론 내 그림은 실제 모습보단 덜해. 그렇다고 내 실수는 아니라고... | . 3 4장 r n r n 난 곧 아주 중요한 두 번째 사실도 알게 됐는데,... | . 4 5장 r n r n 난 매일 그 별과 떠나온 이유와 여행에 대해 알게... | . 5 6장 r n r n 아! 어린 왕자여, 난 이제야 알겠어, 조금씩, ... | . 6 7장 r n r n 다섯 째 날에도, 항상 양 덕분에, 어린 왕자의 ... | . 7 8장 r n r n 나는 곧 이 꽃에 대해 알게 되었다. 어린 왕자의... | . 8 9장 r n 내 생각에, 어린 왕자는, 철새들이 이동할 때 함께 그 별 을... | . 9 10장 r n 어린 왕자의 별 가까이에 소행성 325호, 326호, 327... | . 10 11장 r n r n 두 번째 별엔 허영심쟁이가 살고 있었어요. r ... | . 11 12장 r n r n 술꾼 r n 다음으로 간 별엔 술꾼이 살고 ... | . 12 13장 r n r n 네 번째 별엔 장사꾼이 살고 있었다. 어린 왕자... | . 13 14장 r n r n 다섯 번째 별은 좀 이상했다. 가장 작았기 때문... | . 14 15장 r n r n 여섯 번째 별은 열 배는 큰 별이었다. 거기엔 ... | . 15 16장 r n r n 그리하여 일곱 번째로 들른 별은 지구였다. r ... | . 16 17장 r n r n 뭔 말을 거창하게 하려다 보면, 허풍이 좀 들어... | . 17 18장 r n r n 어린 왕자는 사막을 거닐어보았지만 마주친 거라 ... | . 18 19장 r n r n 어린 왕자는 높은 산에 올랐다. 어린 왕자의 별... | . 19 20장 r n r n 하지만 어린 왕자는 모랫길과 바위와 눈 뿐인 곳을 한... | . 20 21장 r n r n 그런데 그때 여우가 나타났다. r n &quot;안녕... | . 21 &quot;넌 누구니?&quot;라며 어린 왕자가 말했다. &quot;근데 넌 참 귀엽구나...&quot; r ... | . 22 22장 r n r n &quot;안녕하세요.&quot;라며 어린 왕자가 말했다. &quot;안녕... | . 23 23장 r n r n &quot;안녕하세요.&quot;라며 어린 왕자가 말했다. &quot;안녕... | . 24 24장 r n r n 비행기 고장으로 사막에 떨어진지도 이제 여덟째 ... | . 25 25장 r n r n &quot;사람들은,&quot;라며 어린 왕자가 말했다. &quot;서둘러... | . 26 26장 r n r n 그 우물 가 옆엔 무너진 돌담 하나가 있었다. ... | . 27 27장 r n r n 물론 지금은 6년이 지난 얘기다... 난 아직 ... | . &#47928;&#51088;&#50676; &#48712;&#46020; &#44228;&#49328; . counts = final.applymap(lambda x: np.char.count(x, &quot;어린 왕자&quot;)) counts . chapters . 0 0 | . 1 5 | . 2 6 | . 3 7 | . 4 10 | . 5 2 | . 6 5 | . 7 14 | . 8 8 | . 9 24 | . 10 10 | . 11 6 | . 12 11 | . 13 12 | . 14 14 | . 15 0 | . 16 13 | . 17 4 | . 18 7 | . 19 8 | . 20 1 | . 21 23 | . 22 6 | . 23 3 | . 24 12 | . 25 15 | . 26 20 | . 27 12 | . counts.plot(); . &#49892;&#49845; 1. &#52309;&#53552;&#48324;&#47196; &#50668;&#50864;, ?, !&#51032; &#48712;&#46020;&#47484; &#44228;&#49328;&#54616;&#44256; &#44536;&#47548;&#51004;&#47196; &#45208;&#53440;&#45236;&#50612;&#46972;. . counts_fox = final.applymap(lambda x : np.char.count(x, &quot;여우&quot;)) counts_fox . chapters . 0 0 | . 1 0 | . 2 0 | . 3 0 | . 4 0 | . 5 0 | . 6 0 | . 7 0 | . 8 0 | . 9 0 | . 10 0 | . 11 0 | . 12 0 | . 13 0 | . 14 0 | . 15 0 | . 16 0 | . 17 0 | . 18 0 | . 19 0 | . 20 3 | . 21 30 | . 22 0 | . 23 0 | . 24 4 | . 25 2 | . 26 0 | . 27 0 | . counts_fox.plot() . &lt;AxesSubplot:&gt; . counts_n = final.applymap(lambda x: np.char.count(x, &quot;!&quot;)) counts_n . chapters . 0 0 | . 1 2 | . 2 11 | . 3 4 | . 4 7 | . 5 3 | . 6 19 | . 7 9 | . 8 1 | . 9 18 | . 10 5 | . 11 1 | . 12 9 | . 13 6 | . 14 14 | . 15 1 | . 16 4 | . 17 0 | . 18 1 | . 19 2 | . 20 0 | . 21 16 | . 22 0 | . 23 0 | . 24 3 | . 25 8 | . 26 17 | . 27 8 | . counts_n.plot() . &lt;AxesSubplot:&gt; . counts_m = final.applymap(lambda x: np.char.count(x, &quot;?&quot;)) counts_m . chapters . 0 0 | . 1 2 | . 2 10 | . 3 7 | . 4 4 | . 5 2 | . 6 7 | . 7 3 | . 8 1 | . 9 11 | . 10 5 | . 11 4 | . 12 20 | . 13 6 | . 14 16 | . 15 0 | . 16 5 | . 17 2 | . 18 5 | . 19 1 | . 20 0 | . 21 13 | . 22 5 | . 23 2 | . 24 2 | . 25 5 | . 26 7 | . 27 2 | . counts_m.plot() . &lt;AxesSubplot:&gt; .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/09/29/(d%EA%B0%9C%EB%A1%A0-2-1~2-4).html",
            "relUrl": "/python/2022/09/29/(d%EA%B0%9C%EB%A1%A0-2-1~2-4).html",
            "date": " • Sep 29, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "데이터 시각화 과제 3",
            "content": "import numpy as np import matplotlib.pyplot as plt import pandas as pd . np.random.seed(43052) ϵ = np.random.randn(100) . plt.plot(np.arange(1,101),ϵ,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fc76a280580&gt;] . (1) $ epsilon_t$ 와 $ epsilon_{t-1}$은 독립이라고 보여지는가? . 독립이다. . (2) 아래의 수식을 만족하는 벡터 ${ boldsymbol y} = (y_1,y_2, dots, y_{100})$ 을 생성하라. (단 $y_1= epsilon_1$) . $$ y_t = y_{t-1} + epsilon_t$$ . y = np.cumsum(ϵ) #y는 입실론을 다 더한 것 . plt.plot(y,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fc7180cdcd0&gt;] . (3) $(t,y_t)$의 dot-connected plot을 그려라. . ϵ1 = ϵ[:-1] #t-1의 시점 ϵ2 = ϵ[1:] #t의 시점 . y1 = y[:-1] #t-1의 시점 y2 = y[1:] #t의 시점 . plt.plot(y1, y2, &#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fc7395b9fa0&gt;] . (4) $y_t$와 $y_{t-1}$은 독립이라고 볼 수 있는가? . np.corrcoef(y1, y2) . array([[1. , 0.97237553], [0.97237553, 1. ]]) . $y_{t-1}$이 변할 때 $y_t$가 변하므로 독립이 아니다. .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/09/27/%EA%B3%BC%EC%A0%9C3(%EC%96%B4%EB%A0%A4%EC%9B%80).html",
            "relUrl": "/python/2022/09/27/%EA%B3%BC%EC%A0%9C3(%EC%96%B4%EB%A0%A4%EC%9B%80).html",
            "date": " • Sep 27, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "데이터 시각화4",
            "content": "",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/09/23/.html",
            "relUrl": "/python/2022/09/23/.html",
            "date": " • Sep 23, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "데이터 시각화3",
            "content": "&#47928;&#51228;1 . import matplotlib.pyplot as plt import numpy as np . fig, axs = plt.subplots(2, 3) . x,y = [1,2,3,4], [1,2,4,3] axs[0,0].plot(x, y,&#39;or&#39;) axs[1,0].plot(x, y,&#39;--or&#39;) axs[0,1].plot(x, y,&#39;og&#39;) axs[1,1].plot(x, y,&#39;--og&#39;) axs[0,2].plot(x, y,&#39;ob&#39;) axs[1,2].plot(x, y,&#39;--ob&#39;) fig . &#47928;&#51228;2 . fig = plt.figure() ax1 = fig.add_axes([0.5,0.5,1,1]) # (0,0)의 위치에 (1,1)인 액시즈(=네모틀)을 만들어라. ax2 = fig.add_axes([1.0,1.0,1,1]) ax3 = fig.add_axes([1.5,1.5,1,1]) ax1,ax2,ax3 = fig.axes fig.axes . [&lt;Axes:&gt;, &lt;Axes:&gt;, &lt;Axes:&gt;] . x,y = [1,2,3,4], [1,2,1,1] ax1.plot(x, y, &quot;or&quot;) ax2.plot(x, y, &quot;og&quot;) ax3.plot(x, y, &quot;ob&quot;) fig . &#47928;&#51228; 3 . x = np.arange(-5,5,0.1) y1 = np.sin(x) y2 = np.sin(2*x) + 2 y3 = np.sin(4*x) + 4 y4 = np.sin(8*x) + 6 . plt.plot(x, y1, &quot;--r&quot;) plt.plot(x, y2, &quot;--g&quot;) plt.plot(x, y3, &quot;--b&quot;) plt.plot(x, y4, &quot;--m&quot;) . [&lt;matplotlib.lines.Line2D at 0x7fd28a798400&gt;] .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/09/22/fig-axes.html",
            "relUrl": "/python/2022/09/22/fig-axes.html",
            "date": " • Sep 22, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "데이터 시각화2",
            "content": "!pip install opencv-python . Requirement already satisfied: opencv-python in /Users/heji/opt/anaconda3/lib/python3.9/site-packages (4.6.0.66) Requirement already satisfied: numpy&gt;=1.19.3 in /Users/heji/opt/anaconda3/lib/python3.9/site-packages (from opencv-python) (1.21.5) . import cv2 import matplotlib.pyplot as plt import pandas as pd import numpy as np . Collecting opencv-python Downloading opencv_python-4.6.0.66-cp36-abi3-macosx_10_15_x86_64.whl (46.4 MB) |████████████████████████████████| 46.4 MB 613 kB/s eta 0:00:01 Requirement already satisfied: numpy&gt;=1.17.3 in /Users/heji/opt/anaconda3/lib/python3.9/site-packages (from opencv-python) (1.21.5) Installing collected packages: opencv-python Successfully installed opencv-python-4.6.0.66 . #drive.mount(&#39;/content/drive&#39;) . !wget https://raw.githubusercontent.com/guebin/2021DV/master/_notebooks/hw_img.png img =cv2.imread(&#39;hw_img.png&#39;) . --2022-09-23 16:22:35-- https://raw.githubusercontent.com/guebin/2021DV/master/_notebooks/hw_img.png Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.110.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 120618 (118K) [image/png] Saving to: &#39;hw_img.png&#39; hw_img.png 100%[===================&gt;] 117.79K --.-KB/s in 0.02s 2022-09-23 16:22:36 (7.03 MB/s) - &#39;hw_img.png&#39; saved [120618/120618] . img.shape . (531, 468, 3) . plt.imshow(img) . &lt;matplotlib.image.AxesImage at 0x7ff292852eb0&gt; . img_red = img * 0 img_green = img * 0 img_blue = img * 0 . img_red[...,0] = img[...,0] #이미지 색 분리하기 img_green[...,1] = img[...,1] img_blue[...,2] = img[...,2] . plt.imshow(img_red) . &lt;matplotlib.image.AxesImage at 0x7ff2723f8e50&gt; . img_red[:,:,0].shape . (531, 468) . plt.hist(img[:,:,0].reshape(-1)) #색의 히스토그램 그리기 . (array([ 369., 1419., 2494., 3906., 33232., 71030., 60306., 17593., 39230., 18929.]), array([ 28., 45., 62., 79., 96., 113., 130., 147., 164., 181., 198.]), &lt;BarContainer object of 10 artists&gt;) . _fig = plt.hist(img[:,:,0].reshape(-1),bins=255, range=[0,255]) #색의 범위는 0~255 . img2_red = cv2.equalizeHist(img[...,0]) plt.hist(img2_red.reshape(-1)) #히스토그램 평탄화작업 . (array([22189., 25646., 25483., 21440., 26638., 24418., 26942., 25299., 24005., 26448.]), array([ 0. , 25.5, 51. , 76.5, 102. , 127.5, 153. , 178.5, 204. , 229.5, 255. ]), &lt;BarContainer object of 10 artists&gt;) . _fig=plt.hist(img2_red.reshape(-1),bins=255,range=(0,255)) #검은색에서 하양색까지 색을 골고루 쓰게끔 . img2 = np.stack([img2_red,img2_red,img2_red],axis=-1) #빨강 이미지 세개 쌓기 . img2.shape . (531, 468, 3) . plt.imshow(img2) . &lt;matplotlib.image.AxesImage at 0x7ff292d21c40&gt; . plt.imshow(img) #원래 이미지, 회색 빛 . &lt;matplotlib.image.AxesImage at 0x7ff292c8ee50&gt; . 처음부터 흑백으로 불러오기 . img_black =cv2.imread(&#39;hw_img.png&#39;, 0) #흑백 버전으로 그림 불러오기 . img_black2 = cv2.equalizeHist(img_black) . plt.imshow(img_black2, cmap = &#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x7ff280356af0&gt; . plt.imshow(np.concatenate([img_black,img_black2],axis=1),cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x7ff2a079d310&gt; .",
            "url": "https://g-gg-ggg.github.io/Oppps/python/2022/09/14/%EA%B3%BC%EC%A0%9C_%ED%9E%88%EC%8A%A4%ED%86%A0%EA%B7%B8%EB%9E%A8_%EC%9D%B4%ED%80%84%EB%9D%BC%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98.html",
            "relUrl": "/python/2022/09/14/%EA%B3%BC%EC%A0%9C_%ED%9E%88%EC%8A%A4%ED%86%A0%EA%B7%B8%EB%9E%A8_%EC%9D%B4%ED%80%84%EB%9D%BC%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98.html",
            "date": " • Sep 14, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://g-gg-ggg.github.io/Oppps/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://g-gg-ggg.github.io/Oppps/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "it’s me . listener | writer | student | . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://g-gg-ggg.github.io/Oppps/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://g-gg-ggg.github.io/Oppps/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}